\documentclass{book}
\input{preamble}
\begin{document}
\chapter{Natural Deduction and Inductive Definitions}
\section{Introduction}

As we are going to discuss and reason about properties of various programming
languages, we need a formal way to provide a clear, unambiguous specification of
a programming language. Such a specification tool is itself a language, called a
\emph{meta-language}. While meta-languages do not necessarily correspond to
computer programs, as programming languages do, they do provide a \emph{proof
  calculus} that can be used to write formal proofs about languages and the
programs written in them. The target of these proofs and specifications is
called the \emph{object language}, in order to differentiate it from the
meta-language.

Originally developed for formalising
logics, the \emph{Natural Deduction} of Gentzen\todo{cite} is a simple
meta-language which works well for specifying all aspects of programming
languages, ranging from the grammar and syntax, to static checks, to runtime
behaviour of language constructs.

This chapter will introduce a fragment of natural deduction, as well as
demonstrate a few basic proof techniques, which will be used throughout
the rest of the book. 

\section{Judgements and Inference Rules}

At the heart of natural deduction is the notion of a \emph{judgement}. A
judgement is a mathematical statement that a certain property holds, for
example:

\begin{itemize}
\item \<3 + 4 \times 5\> is a valid arithmetic expression
\item the string \<"aba"\> is a palindrome
\item \<0.43423\> is a floating point value
\item the sum of 3 and 5 is 8.
\item the number 3 is not equal to the number 4
\end{itemize}
To prevent the ambiguity that arises from using natural language, we invent some
more structural notation for judgements, as shown below for the above examples:

\noindent {\renewcommand{\arraystretch}{2}\begin{tabularx}{\textwidth}{cXr}
$\quad\bullet$ &  \<3 + 4 \times 5\> is a valid arithmetic expression  & $\pred{3 + 4 \times 5}{ok}$ \\
$\quad\bullet$ & the string \<"aba"\> is a palindrome & $\pred{\text{\<"aba"\>}}{palindrome}$ \\
$\quad\bullet$ & \<0.43423\> is a floating point value & $\pred{0.43423}{float}$ \\
$\quad\bullet$ & the sum of 3 and 5 is 8. & $3 + 5 = 8$ \\
$\quad\bullet$ & the number 3 is not equal to the number 4 & $3 \neq 4$ \\
\end{tabularx}}
Judgements by themselves would be boring and fairly useless. For example, the
judgment $\pred{3 + 4 \times 5}{ok}$ says that $3 + 4 \times 5$ is a valid
arithmetic expression, but we have no way of proving that any other arithmetic
expression is valid. As there are an infinite number of valid expressions, it
would obviously be impossible to explicitly list them all using simple
judgements. Luckily, the set of valid arithmetic expressions is not a random
collection of objects, but can be systematically defined by so-called
\emph{inference rules}.

Inference rules allow us to combine judgements to obtain new judgements and
have the following form\footnote{The format of rules used in proof theory, for
  example in Gentzen's original Natural Deduction paper, is much more general, 
  but this simple format is sufficient for our purposes}:
\[
\inferrule{J_1\;\; J_2\;\; \ldots\;\; J_n}{J}
\]
where the judgements $J_1$ to $J_n$ are called \emph{premises}, and $J$ is
called a \emph{conclusion}.  This can be read in two directions:
\begin{enumerate}
\item If each judgement $J_1 \dots J_n$ holds, then $J$ holds (Implication).
\item In order to prove $J$, it suffices to prove each of $J_1 \dots J_n$.
\end{enumerate}
An inference rule is not required to have any premises at all. Such inference rules are called
\emph{axioms}. 


As an initial example, we will define the set of natural numbers $\mathbb{N}$. Here our judgement will be that a certain number $n$ is in the set of natural numbers, written $n \in \mathbb{N}$. 

Defining $\mathbb{N}$ by listing all its elements would be equivalent to including an axiom for each number:
\begin{gather*}
\inferrule{\ }{0\in \mathbb{N}} \quad \inferrule{\ }{s(0) \in \mathbb{N}} \quad \inferrule{\ }{s(s(0))\in \mathbb{N}} \quad
\cdots
\end{gather*}
 For  simplicity reasons, we represent each successive number $0,1,2,3,\dots$ as a unary encoding: \<0, s(0), s(s(0)),
s(s(s(0))),\dots\>  ($s$ here stands for \textit{successor}).

Apart from the very first rule, note that all of these rules have the form ${s(x) \in \mathbb{N}}$,
where $x \in \mathbb{N}$ has been established by the previously listed axiom. We can generalise this pattern into a rule of inference, giving us the following definition:
\begin{enumerate}
  \item $\conc{0} \in \mathbb{N}$, and
  \item for all $\meta{x}$, if $\meta{x} \in \mathbb{N}$, then  $\conc{s(\meta{x})} \in \mathbb{N}$.
\end{enumerate}
which can be translated directly into the following two inference rules:
\begin{gather*}
\inferrule{\ }{\conc{0} \in \mathbb{N}}\textsc{Zero} \quad  \quad
\inferrule{\meta{x} \in \mathbb{N}}{\conc{s(\meta{x})} \in \mathbb{N}}\textsc{Suc}
\end{gather*}
where $\meta{x}$ can be instantiated to any expression in our object language. 
Here, $\meta{x}$ is an example of a \emph{metavariable}, that is, a variable in our
\emph{meta-language}, which stands for any expression in our \emph{object
  language}. More formally, $\textsc{Suc}$ could be considered as a
\emph{schema} describing an infinite \emph{family} of rules, one for every 
possible substitution for $\meta{x}$. Typically, authors try and syntactically 
distinguish metavariables from concrete symbols in the object language, but it
can still be confusing, particularly if the object language also contains 
variables. To reduce this confusion, we have adopted a simple colour coding 
convention for rules in this book: Metavariables are coloured 
\textcolor{blue}{blue}; syntax from the object language is coloured 
\textcolor{mygreen}{green}; everything else, typeset in black, forms part of the
meta-language syntax.

\section {Deductive Proofs}

As previously mentioned, inference rules work in two ways: we can use them
not just to define when a judgement holds, but also as a means of proof. 

Here are some definitions for finer predicates on
natural  numbers:  $\textsf{\textbf{Even}}$, and its opposite, $\textsf{\textbf{Odd}}$.
\begin{gather*}
\inferrule{\ }{\predc{0}{Even}}\textsc{Zero}\quad 
\inferrule{\predm{x}{Even}}{\predc{s(s(\meta{x}))}{Even}}\textsc{Step}\\
\inferrule{\  }{\predc{s(0)}{Odd}}\textsc{One}\quad 
\inferrule{\predm{x}{Odd}}{\predc{s(s(\meta{x}))}{Odd}}\textsc{Step}'
\end{gather*}
Assume we want to prove that the judgement \<\predc{s(s(0))}{Even}\> holds. We
have to look for a rule which has \<\predc{s(s(0))}{Even}\> as a conclusion.
There are no axioms that show this goal directly, but if we \emph{instantiate}
the metavariable $\meta{x}$ to be $\conc{0}$ in the $\textsc{Step}$ rule schema, 
we have the rule:
\[\inferrule{\predc{0}{Even}}{\predc{s(s(0))}{Even}}\textsc{Step}^0\]
Therefore, we know that it suffices to prove $\predc{0}{Even}$ in order to show
our goal, which is easily satisfied by the axiom $\textsc{Zero}$.

Similarly, we can show that \<\predc{s(s(s(s(s(0)))))}{Odd}\> by repeatedly
instantiating the $\textsc{Step'}$ rule until the problem is reduced to the
$\textsc{One}$ axiom. An alternative and often quite convenient way to
write inference proofs is to stack the rules applied to each goal, and draw a
``proof tree'' --- in our example, more a proof stack, since each rule has
just a single premise. 
\[
\inferrule*[Right=Step']{
  \inferrule*[Right=Step']{
    \inferrule*[Right=Step']{
      \inferrule*[Right=One]{\ }{
      \predc{s(0)}{Odd}}}{
      \predc{s(s(0))}{Odd}}
  }{\predc{s(s(s(0)))}{Odd}}
}{
  \predc{s(s(s(s(s(0)))))}{Odd}
}
  \]
It's important to note that our rules of inference have a purely syntactic
basis. Given the rules above, we are not able to prove something like 
\<\predc{2}{Even}\>, even though we can show that \<\predc{s(s(0))}{Even}\>,
and we know that \<\conc{s(s(0))}\> is equivalent to \<\conc{2}\>. We cannot
apply that equivalence since we have no rule which tells us how to do so. 
We are forced to simply manipulate terms mechanically according to the 
given rules.

\newcommand{\mconc}[1]{\texttt{\conc{#1}}}
Let us examine a slightly more interesting example. Suppose we want to define the
language \<\sansbold{M}\> which contains all expressions of properly matched parenthesis
(and no other characters):\footnote{$\epsilon$ represents the empty string}
\[M = \{\conc{\epsilon}, \mconc{()}, \mconc{()()}, \mconc{()()()}, \ldots, \mconc{(())}, \mconc{((()))}, \ldots, \mconc{()(())},\mconc{()()(())}, \ldots \}\] 
Again, let us start by describing the rules in
(semi-)natural language. There are essentially two ways to ``legally'' combine
parentheses: we can either nest them, or concatenate them.
\begin{enumerate}
\item  The empty string (denoted  by $\conc{\epsilon}$) is in \<\sansbold{M}\>
\item  If \<\meta{s_1}\> and \<\meta{s_2}\> are in \<\sansbold{M}\>, then \<\meta{s_1s_2}\> is in \<\sansbold{M}\>
\item   If \<\meta{s}\> is in \<\sansbold{M}\>, then \<\mconc{(}\meta{s}\mconc{)}\> is in \<\sansbold{M}\>
\end{enumerate}
Directly translating into inference rules, we get:

\begin{gather*}
\inferrule{\ }{\predc{\epsilon}{M}}(1) \quad
\inferrule{\predm{s_1}{M}\quad\predm{s_2}{M}}{\predm{s_1s_2}{M}}(2) \quad
\inferrule{\predm{s}{M}}{\pred{\mconc{(}\meta{s}\mconc{)}}{M}}(3)
\end{gather*}

How can we show that  \<\mathtt{\mconc{()(())}}\> is in \<\sansbold{M}\>? As 
we did previously, we check if there is a rule whose conclusion matches the 
judgement we want to infer. If we apply (2), we have to show that both 
$\mconc{()}$ and $\mconc{(())}$ are in $\sansbold{M}$. Since $\mconc{()}=\conc{\texttt{(}\epsilon\texttt{)}}$, 
we can apply (3), and only have to show that $\conc{\epsilon}$ is in
$\sansbold{M}$, which is simply the axiom~(1). By applying the rules~(3) and (1) 
in the same way, we can show that $\mconc{(())}$ is in $\sansbold{M}$ as well, and we 
are done: 

\begin{gather*}
\inferrule*[Right=(2)]{\inferrule*[Right=(3)]
                                  {\inferrule*[Right=(1)]
                                              {\ }
                                              {\predc{\epsilon}{M}}}
                                  {\predc{\texttt{()}}{M}}  
                    \\ \inferrule*[Right=(3)]
                                  {\inferrule*[Right=(3)]
                                              {\ \inferrule*[Right=(1)]
                                                            {\ }
                                                            {\predc{\epsilon}{M}} }
                                              {\predc{\texttt{()}}{M}} }
                                  {\predc{\texttt{(())}}{M}}}
                      {\predc{\texttt{()(())}}{M}}
\end{gather*}
%
The problem is, however, not as straightforward as it seems, because instead
of applying rule~(2), we could as well apply rule~(3):
\begin{gather*}
\inferrule*[Right=(3)]{\inferrule*{?}{\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}
\end{gather*}

As the rule has a single premise, we only have to prove that $\mconc{)(()}$ is
in $\sansbold{M}$. The only rule that's applicable now is rule~(2), and we could apply it in
several different ways resulting in different subgoals:

\begin{gather*}
\inferrule{\inferrule*[Right=(2)]
                                  {\predc{\epsilon}{M} \\ \predc{\texttt{)(()}}{M} }
                                  {\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}(3)
\enskip \mathit{or} \enskip 
\inferrule{\inferrule*[Right=(2)]
                                  {\predc{\texttt{)}}{M} \\ \predc{\texttt{(()}}{M} }
                                  {\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}(3)
\enskip \mathit{or} \enskip
\inferrule{\inferrule*[Right=(2)]
                                  {\predc{\texttt{)(}}{M} \\ \predc{\texttt{()}}{M} }
                                  {\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}(3) \\
\mathit{or} \\
\inferrule{\inferrule*[Right=(2)]
                                  {\predc{\texttt{)((}}{M} \\ \predc{\texttt{)}}{M} }
                                  {\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}(3)
\enskip \mathit{or} \enskip
\inferrule{\inferrule*[Right=(2)]
                                  {\predc{\texttt{)(()}}{M} \\ \predc{\epsilon}{M} }
                                  {\predc{\texttt{)(()}}{M}}}
                      {\predc{\texttt{()(())}}{M}}(3)
\end{gather*}
We can immediately rule out the first and last options because, while they have
one easily provable subgoal (that $\conc{\epsilon}$ is in $\sansbold{M}$),
they get us no closer to proving our overall goal. 
In the second and the fourth application, we end up with the goal $\pred{\mconc{)}}{M}$, but there
is no rule which we can apply to discharge it. This is not that
surprising, since $\sansbold{M}$ should only contain expressions of properly matched
parentheses, and $\mconc{)}$ (as well as $\mconc{)(()}$) is not properly matched. So, by
choosing the wrong rule, or applying the right rule in a wrong way -- for example,
splitting $\mconc{()()}$ up into $\mconc{()(}$ and $\mconc{)}$ --
it is easily possible to end up with goals which
are not actually provable and reach a dead end. In our example, this was not hard
to see. It's also possible that there exists multiple proofs of the same
property. For example, $\pred{\mconc{()}}{M}$ can be shown an infinite number of
ways:

\begin{gather*}
\inferrule{\inferrule*[Right=(1)]
                         {\ }
                         {\predc{\epsilon}{M}} }
           {\predc{\texttt{()}}{M}}(3)
\enskip \mathit{or} \enskip
\inferrule{\inferrule*[Right=(1)]{\ }{\predc{\epsilon}{M}} \\ \inferrule*[Right=(3)]{\ \inferrule*[Right=(1)]
                         {\ }
                         {\predc{\epsilon}{M}} }
           {\predc{\texttt{()}}{M}}}
          {\predc{\texttt{()}}{M}}(2)
\enskip \mathit{or} \enskip
\inferrule{\inferrule*[Right=(2)]{\inferrule*[Right=(1)]{\ }{\predc{\epsilon}{M}} \\ \inferrule*[Right=(3)]{\ \inferrule*[Right=(1)]
                         {\ }
                         {\predc{\epsilon}{M}} }
           {\predc{\texttt{()}}{M}}}
          {\predc{\texttt{()}}{M}} \\ \inferrule*[Right=(1)]{\ }{\predc{\epsilon}{M}} }{\predc{\texttt{()}}{M}}(2)
\enskip \cdots
\end{gather*}
It can be extremely difficult to decide which rule to apply
and how, without some background knowledge about the objects and properties, as
there might be an infinite number of possibilities. This is one reason why it
is not possible in general to write a program which automatically infers
judgements that is guaranteed to find such a derivation if it exists.

\subsection{Derivable and  Admissible Rules}
What would happen if we added the following rule:
\[
(4)\qquad\inferrule{\pred{s}{M}}{\pred{\mathtt{((}s\mathtt{))}}{M}}
\]
Does this change the set $M$ in any way, that is, is there a string $s$ for which
we can infer $\pred{s}{M}$ if we use $4$, but not otherwise? This doesn't
seem very likely: the rule just says that, if a string $s$ is in $M$ it is ok
to add two pairs of matching parenthesis. Since we already had a rule which
allows us to add one pair of parenthesis, we can apply this rules twice and
achieve the same effect: 
\[
\qquad\inferrule{\inferrule{\pred{s}{M}}{\pred{\mathtt{(}s\mathtt{)}}{M}}}{\pred{\mathtt{((}s\mathtt{))}}{M}}
\]
This means that Rule $(4)$ is \emph{derivable} from the existing
rules. 

In all the previous rules, the strings in the premises were simpler than the
string in the conclusion. The following rule if different in this respect: 
\[
(5)\qquad\inferrule{\pred{\mathtt{()}s}{M}}{\pred{s}{M}}
\]
Interestingly, although Rule~$(4)$  does not introduce any new strings to $M$, the rule
is also not derivable from any of the existing rules. Such  a rule is called
\emph{admissible}.


\section{Induction} 

Natural deduction by itself is sometimes not powerful enough. For example,
although we can see that the Rule $(5)$ is valid for every string $s$
in $M$, we cannot show this by simply combining the existing rules. We will
therefore introduce another proof technique here, called \emph{induction}. You
will probably know induction over natural numbers and structural induction
from mathematics and previous courses. Both are special cases of a more
general induction principle called \emph{rule induction}. 


A set of inference rules $R$ defining a set $A$ is called an \emph{inductive
  definition} of $A$, if $\pred{s}{A}$ holds if and only if $\pred{s}{A}$ is
derivable using $R$. Not all sets can be defined using inductive
definitions. For example, while natural numbers are one of the standard
examples for such sets, floating point numbers cannot be defined in such a
way. 



\subsection{Rule Induction}
Let us go back to our previous example set $M$ of properly matched
parenthesis. The rules $1$ to $3$ provide an inductive definition of $M$: 
\begin{eqnarray*}
(1)&\qquad\phantom{a} &  \Large{\inferrule{\phantom{asdasd}}{\pred{\epsilon}{M}}}\\ \phantom{a}\\
(2)& &  \Large{\inferrule{\predand{s_1}{M}\pred{s_2}{M}}{\pred{s_1s_2}{M}}}\\ \phantom{a}\\
 (3)&& \Large{\inferrule{\pred{s}{M}}{\pred{\mathtt{(}s\mathtt{)}}{\;M}}}
\end{eqnarray*}
Now, let us assume we want to prove some property $P$ of the strings in $M$,
that is: show that if $\pred{s}{M}$ then $\pred{s}{P}$. Since we know that
there is a derivation for each $\pred{s}{M}$, we  only need to show
that:
\begin{itemize}
  \item $\pred{\epsilon}{P}$
  \item if  $\pred{s_1}{P}$ and $\pred{s_2}{P}$, then $\pred{s_1 s_2}{P}$
  \item if  $\pred{s}{P}$, then $\pred{(s)}{P}$
\end{itemize}
Which in essence correspond to the original rules only with $M$ replaced by $P$. For
example, if we want to show that all $s$ in $M$ have the same number of opening and
closing brackets, we need to prove the following statements (where
\textit{open} denotes the number of opening, \textit{close} those of closing brackets):
\begin{enumerate}
\item   \<open({\epsilon}) = close (\epsilon)\>

  \textbf{Proof:}   \<open({\epsilon}) = 0 = close (\epsilon)\>

\item if \<open({s_1}) = close (s_1)\> and \<open({s_2}) = close (s_2)\> then 
  \<open({s_1 s_2}) = close (s_1 s_2)\>

  For the proof, we assume that the statements corresponding to the judgements
  in the premises of the rules hold. These assumptions are called the
  \emph{induction hypothesis}. 

  \begin{itemize}
    \item Induction Hypothesis 1:  \<open({s_1}) = close (s_1)\>

    \item Induction Hypothesis 2:   \<open({s_2}) = close (s_2)\>
  \end{itemize}
  
  \textbf{Proof:} \<open({s_1 s_2}) = open(s_1) + open (s_2) =close(s_1) +
  close (s_2) = close (s_1 + s_2)\>
  
\item if \<open({s}) = close (s)\> then \<open(\mathtt{(}s\mathtt{)})\> 
  \begin{itemize}
  \item Induction Hypothesis 1:  \<open({s}) = close (s)\>
  \end{itemize}
    
  \textbf{Proof:} 
\begin{displaymath}
\begin{array}{lcl}
	&& open(\mathtt{(}s\mathtt{)}) \\
	&=& \text{\{property of \textit{open}\}}\\
   && open(\mathtt{(}) + open(s) +open(\mathtt{)})\\
	&=& \text{\{property of \textit{open}\}}\\
&& 1  + open (s) + 0  \\
		&=& \text{\{Induction Hypothesis,Arithmetic\}}\\
		 && 1  + close (s) + 0 \\
		&=& \text{\{property of \textit{close}\}}\\
	   && close(\mathtt{(}) + close(s) + close(\mathtt{)})\\
				&=& \text{\{property of \textit{close\}}}\\
					&& close(\mathtt{(}s\mathtt{)}) 
\end{array}
\end{displaymath}

\end{enumerate}

In the proof, we used the rules of arithmetic, and that properties of \<close\> and \<open\>, such as \<open(\mathtt{(}) = close (\mathtt{)}) = 1\>, and \<open(\mathtt{)})= close(\mathtt{(}) = 0\>. In a fully formal proof, we would also need a formal definition of these two functions.


\subsection{Ambiguity}
The definition of $M$, although correct, has a undesirable property: for
any string in $M$, we do not have just one derivation, but an
infinite number of possible derivations, since any string $s$ can be split
into  $\epsilon$ and $s$ by applying Rule~(2), and then Rule~(1) to get rid of
 $\epsilon$. However, this derivation step is completely unnecessary. 

 Fortunately, if we take a more structured view on the elements of this
 language, we can come up with an alternative set of rules, where we have
 exactly one derivation for each string in the set. We can interpret each
 string as a possibly empty list ($L$) of non-empty parenthesis expressions
 ($N$) according to the following inference rules: 
\begin{eqnarray*}
(1) & \inferrule{}{\pred{\epsilon}{L}}\\
(2) & \inferrule{\predand{s_1}{N}\pred{s_2}{L}}{\pred{\epsilon}{L}}\\
(2) & \inferrule{\pred{s}{L}}{\pred{\mathtt{(}s\mathtt{)}}{N}}\\
\end{eqnarray*}
The interesting point here is that $L$ and $N$ are defined in terms of each
other: we have a mutually recursive definition. 

Let us look at one more example of an ambiguous definition: simple
arithmetic expressions, given here both in EBNF form and as inductive
definition using inference rules:

The EBNF
  \begin{grammar}
     \grule{Expr}{%
       \gnterm{int}\ \galt\ (\gnterm{Expr}) 
       \galt\ {\gnterm{Expr} + \gnterm{Expr}\ 
       \galt\ {\gnterm{Expr} * \gnterm{Expr}}}}
   \end{grammar}
 describes the same language as the following set of inference rules ($\gnm{int}$  represents an integer constant):
  \begin{gather*}
\inferrule{\pred{e}{\gnm{Expr}}}{\pred{(e)}{\gnm{Expr}}}\qquad
\inferrule{\predand{e_1}{\gnm{Expr}} \pred{e_2}{\gnm{Expr}}}{\pred{e_1\;\texttt{+}\;\;e_2}{\gnm{Expr}}}
\qquad
\inferrule{\predand{e_1}{\gnm{Expr}}\pred{e_2}{\gnm{Expr}}}{\pred{e_1\;\texttt{*}\;\;e_2}{\gnm{Expr}}}
  \end{gather*}
Although in this case, there are not an infinite number of possible
derivations for each expression, every expression which contains more than a
single arithmetic operation still can be derived in more than one way:
\begin{gather*}
    \inferrule{\inferrule{\inferrule{}{1\; \gnm{Expr}}\quad
        \inferrule{}{2\; \gnm{Expr}}}{1 + 2\; \gnm{Expr}}\;\;
      \inferrule{}{3\;\gnm{Expr}}}{%
        1+2*3\;\gnm{Expr}}
  \end{gather*}
\begin{gather*}
    \inferrule{
      \inferrule{}{1\;\gnm{Expr}}\;\;
\inferrule{\inferrule{}{2\; \gnm{Expr}}\quad
        \inferrule{}{3\; \gnm{Expr}}}{2 * 3\; \gnm{Expr}}
    }{%
        1+2*3\;\gnm{Expr}}
  \end{gather*}

  Although both derivations are correct with respect to the rules given, the
  second derivation is more appropriate for an arithmetic expression, as it
  decomposes the expression first into two summands. We give an alternative
  definition, which takes precedence and associativity  of the operators into
  account:
  
  \begin{gather*}
\inferrule{\predand{e_1}{\gnm{SExpr}}\pred{e_2}{\gnm{PExpr}}}{\pred{e_1\;\;\texttt{+}\;e_2}{\gnm{SExpr}}}
\qquad
\inferrule{\pred{e}{\gnm{PExpr}}}{\pred{e}{\gnm{SExpr}}}
\end{gather*}

\begin{gather*}
\inferrule{\predand{e_1}{\gnm{PExpr}}\pred{e_2}{\gnm{FExpr}}}{\pred{e_1\;\texttt{*}\;\;e_2}{\gnm{PExpr}}}
\qquad
\inferrule{e\; FExpr}{e\;PExpr}
  \end{gather*}


\begin{gather*}
\inferrule{e\; SExpr}{\texttt{(}e\texttt{)}\;FExpr}\qquad
\inferrule{}{int\;FExpr}
  \end{gather*}
The unambiguous grammar is, again, much more complicated than the original
grammar, even for such a simple language. This is not surprising, as it
contains additional structural information. For programming languages, ambiguous
grammars are problematic, as they may allow different interpretations of
programs, and are therefore usually avoided. 

\subsection{Simultaneous Induction}
How can we apply the principle of rule induction to mutually recursive
definitions like those of $L$ and \textit{SExpr}? In most cases, we have to
generalise the proof goal. For example, if we want to prove a property $P$ for all
$e$ in \textit{SExpr}, that is \<\pred{e}{SExpr}\> implies \<\pred{e}{PExpr}\>.
By the principle of rule induction we have to show that 
\begin{itemize}
\item under the assumption that
\begin{itemize}
 \item[-] \<e = e_1 + e_2\>
 \item[-] \<\pred{e_1}{SExpr}\>
 \item[-] \<\pred{e_2}{PExpr}\>
 \end{itemize}
 and the Induction Hypothesis 
\begin{itemize}
  \item[-]  \<\pred{e_1}{P}\>
  \end{itemize}
  show that   \<\pred{e_1+e_2}{P}\>
\item under the assumption that
  \begin{itemize}
  \item[-] \<\pred{e}{PExpr}\>
  \end{itemize}
  show that \<\pred{e}{P}\>
\end{itemize} 

The problem is that, since we only try to show something about
\<SExpr\>, the induction hypothesis does not say anything about \<e_2\> (we
only know that \<\pred{e_2}{PExpr}\>, and nothing at all about $e$ in for the
second rule. In most cases, this is not enough to prove anything. The
solution is often to try and prove a more general statement instead which
leads to stronger induction hypothesis. If we try to show, for instance, that 
\<\pred{e}{SExpr}\> or \<\pred{e}{PExpr}\> or \<\pred{e}{FExpr}\> implies \<\pred{e}{P}\>,
we have more cases to cover on one hand (one for each inference rule which has
\textit{PExpr}, \textit{SExpr} or \textit{FExpr} in the conclusion), on the other hand the induction
hypothesis cover all the premises in the rules:
\begin{itemize}
\item under the assumption that
\begin{itemize}
 \item[-] \<e = e_1 + e_2\>
 \item[-] \<\pred{e_1}{SExpr}\>
 \item[-] \<\pred{e_2}{PExpr}\>
 \end{itemize}
 and the Induction Hypothesis 
\begin{itemize}
  \item[-]  \<\pred{e_1}{P}\>
  \item[-]  \<\pred{e_2}{P}\>
  \end{itemize}
  show that   \<\pred{e_1+e_2}{P}\>
\item under the assumption that
  \begin{itemize}
  \item[-] \<\pred{e}{PExpr}\>
  \end{itemize}
 and the Induction Hypothesis 
 \begin{itemize}
 \item[-]  \<\pred{e}{P}\>
 \end{itemize}
 show that \<\pred{e}{P}\> (trivial)
\item under the assumption that
\begin{itemize}
 \item[-] \<e = e_1 * e_2\>
 \item[-] \<\pred{e_1}{SExpr}\>
 \item[-] \<\pred{e_2}{PExpr}\>
 \end{itemize}
 and the Induction Hypothesis 
\begin{itemize}
  \item[-]  \<\pred{e_1}{P}\>
  \item[-]  \<\pred{e_2}{P}\>
  \end{itemize}
  show that   \<\pred{e_1*e_2}{P}\>
  
\item \ldots
\end{itemize} 


\section{Judgements and Relations}
So far, we defined a judgement to be a statement about a property of an
object. We can generalise this definition to relation between a number of
objects. Consider the following inductive definition of the  relation ``a divides b'' on natural
numbers. For convenience reasons, we choose an infix notation here:
  \begin{gather*}
\inferrule{}{0\;div\; n}\\\phantom{a}\\
\inferrule{n\; div\; m}{n\; div\; (m+n)}
\end{gather*}
As before, we can also view this as an inductive definition of a set. In this
case, a set of pairs, where $(a,b)$ in \textit{div} if and only if $a$ divides
$b$. Rule inductions works exactly in the same way as in the unary case.

\section{Boolean Expression Example}		
As another example, consider boolean expressions. For simplicity, we only include three operators for now: $\wedge$, $\vee$, and $\neg$, the constants \textit{True} and \textit{False}, and parentheses. Our first attempt at defining a set of inference rules to characterise boolean expressions might look as follows:

  \begin{gather*}
	\inferrule{\phantom{bla}}{\pred{\bf{True}}{\gnm{BExpr}}}\qquad \inferrule{\phantom{bla}}{\pred{\bf{False}}{\gnm{BExpr}}}\qquad \inferrule{\pred{e}{\gnm{BExpr}}}{\neg\pred{e}{\gnm{BExpr}}}\\ \\
\inferrule{\pred{e}{\gnm{BExpr}}}{\pred{(e)}{\gnm{BExpr}}}\qquad
\inferrule{\predand{e_1}{\gnm{BExpr}} \pred{e_2}{\gnm{BExpr}}}{\pred{e_1 \wedge e_2}{\gnm{BExpr}}}
\qquad
\inferrule{\predand{e_1}{\gnm{BExpr}}\pred{e_2}{\gnm{BExpr}}}{\pred{e_1\vee e_2}{\gnm{BExpr}}}
  \end{gather*}

Unfortunately, with this set of rules, we have the same problem we had with our rules for arithmetic expressions. Even though they inductively define the set of boolean expressions, they are ambiguous and do not reflect  associativity and precedence of the operators. So, we need to come up with an alternative definition. The operator $\neg$ has the highest precedence, $\vee$ the lowest, and both $\wedge$ and $\vee$ are left associative. The solution is also similar to the solution for arithmetic expressions. First, we need rules to define the subset of boolean expressions  which can be arguments of the operator with the highest precedence, negation. These can only be atomic expressions (constants), any expression in parentheses, or such an expression preceded by negation. Let's call this subset \textit{NbExpr}. We call the boolean expressions we generate with the new rules \textit{Bexpr}.
  \begin{gather*}
	\inferrule{\phantom{bla}}{\pred{\bf{True}}{\gnm{Nbexpr}}}\qquad \inferrule{\phantom{bla}}{\pred{\bf{False}}{\gnm{Nbexpr}}}\qquad \inferrule{\pred{e}{\gnm{Bexpr}}}{\neg\pred{(e)}{\gnm{Nbexpr}}}\\ \\
  \end{gather*}
The rules for the operators $\wedge$ and $\vee$ correspond to those for addition and multiplication. Since the operators are left associative, the expression on the left hand side can only be an expression with stronger cohesion than the one on the right hand side. For the $\wedge$ operator, it has to be a $Nbexpr$.
\begin{gather*}
	\inferrule{\predand{e_1}{\gnm{NbExpr}} \pred{e_2}{\gnm{Abexpr}}}{\pred{e_1\wedge e_2}{\gnm{Abexpr}}}
	\qquad
	\inferrule{\predand{e_1}{\gnm{Abexpr}}\pred{e_2}{\gnm{Bexpr}}}{\pred{e_1\vee e_2}{\gnm{Bexpr}}}
\end{gather*}	
And finally we need rules to express the fact the $Nbexpr \subseteq Abexpr \subseteq Bexpr$
\begin{gather*}
	\inferrule{\pred{e}{\gnm{Nbexpr}}}{\pred{e}{\gnm{Abexpr}}}
	\qquad
	\inferrule{\pred{e}{\gnm{Abexpr}}}{\pred{e}{\gnm{Bexpr}}}
\end{gather*}	


\end{document}